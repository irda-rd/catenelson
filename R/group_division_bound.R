#' @title Group division bound
#' @description Evaluate column index of a division object that respect bounding restriction on their corresponding critical values.
#' @param x \code{numeric}, an ordered vector of elements.
#' @param min_crit,max_crit \code{numeric} vectors of length corresponding to the number of group (number of rows of \code{division}) minus one, representing inequality constraints on each critical values in \code{x} \code{(min <= x <= max)}. The default value is \code{NULL} and represent no constraint.
#' @param division \code{matrix} of position that define a new group (rows) for different partitions (columns), as generated by the function group_division; alternatively a \code{numeric} vector representing a single partition.
#' @return Return a \code{logical} vector indication which column of \code{division} that respect the constraints.
#' @export
#' @examples
#' #General example
#' x <- c(9,11, sample(12:19, 3), 20,22)
#' division <- group_division(x, n_group = 3, min_group = 1)
#' group_division_bound(x, division, min_crit = c(11,11), max_crit = c(20,20))
#' 
group_division_bound <- function(x, division, min_crit = NULL, max_crit = NULL){
  #Initialising min and max if undefined
  if(is.null(min_crit)){
    min_crit <- rep(-Inf, nrow(division))
  }
  if(is.null(max_crit)){
    max_crit <- rep(Inf, nrow(division))
  }
  
  #Compute critical values associated to the division
  crit_x_df <- as.data.frame(t(group_crit(x, division)), stringsAsFactors = FALSE)
  names(crit_x_df) <- paste0("crit_x_", seq_len(nrow(division)))
  crit_logical <- rep(TRUE, nrow(crit_x_df))
  
  #Identify divisions that respect lower and upper bound defined by min and max
  for(j in seq_len(ncol(crit_x_df))){
    crit_logical <- crit_logical & (crit_x_df[[j]] >= min_crit[j]) & (crit_x_df[[j]] <= max_crit[j])
  } 

  return(crit_logical)
}
