#' @title Group division check
#' @description Check that a division vector or matrix is appropriate.
#' @param n_row \code{integer}, the number of row of the matrix to build, which should equal the length of the vector to be classified.
#' @param division \code{matrix} of position that define a new group (rows) for different partitions (columns), as generated by the function group_division; alternatively a \code{numeric} vector representing a single partition.
#' @return Return \code{TRUE} if properties of \code{division} are appropriate and an error otherwise.
#' @export
#' @examples
#' #General example
#' ##Data
#' x <- sample(1:100, 10)
#' division <- group_division(x, n_group = 2, min_group = 2)
#'
#' ##Case that return TRUE, select n_row = 5 for an example that return an error.
#' group_division_check(n_row = length(x), division)
#' group_division_check(n_row = length(x), division[,1])
#'
setGeneric("group_division_check", function(n_row, division) standardGeneric("group_division_check"))
setMethod("group_division_check", signature(division = "matrix"), function(n_row, division) {
  #Call the function for each column (partition)
  respect <- TRUE
  for(i in seq_len(ncol(division))){
    respect <- respect & group_division_check(n_row, division[,i])
  }
  return(respect)
})

setMethod("group_division_check", signature(division = "ANY"), function(n_row, division) {
  #Identify if the division vector is appropriate
  logical_too_large <- any(division > n_row)
  logical_duplicated <- length(which(duplicated(division))) > 0L
  logical_smaller_than_two <- any(division < 2)
  logical_not_integer <- any(division %% 1 != 0)
  logical_unsorted <- any(division != sort(division))

  if(logical_too_large | logical_duplicated | logical_smaller_than_two | logical_not_integer | logical_unsorted){
    stop("inapropriate division vector")
  }else{
    respect = TRUE
  }

  return(respect)
})
